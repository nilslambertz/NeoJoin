/*
 * generated by Xtext
 */
package tools.vitruv.neojoin.jvmmodel;

import com.google.inject.Inject;
import com.google.inject.name.Named;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import tools.vitruv.neojoin.Constants;
import tools.vitruv.neojoin.ast.ViewTypeDefinition;

/**
 * Xbase expressions within an Xtext language work by defining a jvm model (= a set of classes).
 * This model is used by Xtext for type checking and code completion in Xbase expressions.
 * This class infers such a jvm model
 * <ul>
 *     <li>for all source models to tell Xtext which classes and features are available and their types (see {@link SourceModelInferrer}) and</li>
 *     <li>embeds every expression within the query file into a method to tell Xtext the available local variables,
 *     their types and the expected return type of the expression (see {@link QueryModelInferrer})</li>
 * </ul>
 * Further information can be found in the <a href="https://eclipse.dev/Xtext/documentation/305_xbase.html#xbase-inferred-type">Xtext documentation</a>.
 */
public class NeoJoinJvmModelInferrer extends AbstractModelInferrer {

	@Inject
	private JvmTypesBuilder typesBuilder;

	@Inject
	@Named(Constants.ImportPackageRegistry)
	private EPackage.Registry packageRegistry;

	@Inject
	private ExpressionHelper expressionHelper;

	@Override
	public void infer(EObject obj, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {
		if (obj instanceof ViewTypeDefinition viewType) {
			var typeRegistry = getOrCreateSourceModelTypes(viewType.eResource().getResourceSet());
			new QueryModelInferrer(
				acceptor,
				viewType,
				typeRegistry,
				typesBuilder,
				_typeReferenceBuilder,
				expressionHelper
			).infer();
		} else {
			super.infer(obj, acceptor, preIndexingPhase);
		}
	}

	private static final URI SourceTypeRegistryURI = URI.createURI("SourceTypeRegistry");

	/**
	 * Create source meta-model types only once per resource set and share them between different resources
	 * (i.e., different NeoJoin query files opened simultaneously in the IDE). This saves same resources and
	 * more importantly prevents collisions that would otherwise occur if the same source class is generated
	 * within multiple resources within the same resource set.
	 */
	private TypeRegistry getOrCreateSourceModelTypes(ResourceSet resourceSet) {
		var typeRegistry = (TypeRegistry) resourceSet.getResource(SourceTypeRegistryURI, false);
		if (typeRegistry == null) {
			typeRegistry = new TypeRegistry(SourceTypeRegistryURI);
			new SourceModelInferrer(typeRegistry, packageRegistry, _typeReferenceBuilder).infer();
			resourceSet.getResources().add(typeRegistry);
		}

		return typeRegistry;
	}

}
